schema {
  query: query
  mutation: mutation
  subscription: subscription
}

"""An account record according to the daemon"""
type Account {
  """The public identity of the account"""
  publicKey: PublicKey!

  """The token associated with this account"""
  tokenId: TokenId!

  """The token associated with this account"""
  token: TokenId! @deprecated(reason: "Use tokenId")

  """The timing associated with this account"""
  timing: AccountTiming!

  """The amount of MINA owned by the account"""
  balance: AnnotatedBalance!

  """
  A natural number that increases with each transaction (stringified uint32)
  """
  nonce: AccountNonce

  """
  Like the `nonce` field, except it includes the scheduled transactions
  (transactions not yet included in a block) (stringified uint32)
  """
  inferredNonce: AccountNonce

  """
  The account that you delegated on the staking ledger of the current block's epoch
  """
  epochDelegateAccount: Account

  """Top hash of the receipt chain Merkle-list"""
  receiptChainHash: ChainHash

  """
  The public key to which you are delegating - if you are not delegating to anybody, this would return your public key
  """
  delegate: PublicKey @deprecated(reason: "use delegateAccount instead")

  """
  The account to which you are delegating - if you are not delegating to anybody, this would return your public key
  """
  delegateAccount: Account

  """
  The list of accounts which are delegating to you (note that the info is
  recorded in the last epoch so it might not be up to date with the current
  account status)
  """
  delegators: [Account!]

  """
  The list of accounts which are delegating to you in the last epoch (note that
  the info is recorded in the one before last epoch epoch so it might not be up
  to date with the current account status)
  """
  lastEpochDelegators: [Account!]

  """The previous epoch lock hash of the chain which you are voting for"""
  votingFor: ChainHash

  """
  True if you are actively staking with this account on the current daemon -
  this may not yet have been updated if the staking key was changed recently
  """
  stakingActive: Boolean!

  """Path of the private key file for this account"""
  privateKeyPath: String!

  """
  True if locked, false if unlocked, null if the account isn't tracked by the queried daemon
  """
  locked: Boolean

  """
  The index of this account in the ledger, or null if this account does not yet have a known position in the best tip ledger
  """
  index: Int

  """
  The URI associated with this account, usually pointing to the zkApp source code
  """
  zkappUri: String

  """
  The 8 field elements comprising the zkApp state associated with this account encoded as bignum strings
  """
  zkappState: [FieldElem!]

  """
  Boolean indicating whether all 8 fields on zkAppState were last set by a proof-authorized account update
  """
  provedState: Boolean

  """Permissions for updating certain fields of this account"""
  permissions: AccountPermissions

  """The symbol for the token owned by this account, if there is one"""
  tokenSymbol: String

  """Verification key associated with this account"""
  verificationKey: AccountVerificationKeyWithHash

  """Action state associated with this account"""
  actionState: [Action!]

  """
  The base58Check-encoded hash of this account to bootstrap the merklePath
  """
  leafHash: FieldElem

  """
  Merkle path is a list of path elements that are either the left or right hashes up to the root
  """
  merklePath: [MerklePathElement!]
}

"""Kind of authorization required"""
enum AccountAuthRequired {
  None
  Either
  Proof
  Signature
  Impossible
}

"""account nonce"""
scalar AccountNonce

type AccountPermissions {
  """Authorization required to edit zkApp state"""
  editState: AccountAuthRequired!

  """Authorization required to send tokens"""
  send: AccountAuthRequired!

  """Authorization required to receive tokens"""
  receive: AccountAuthRequired!

  """Authorization required to access the account"""
  access: AccountAuthRequired!

  """Authorization required to set the delegate"""
  setDelegate: AccountAuthRequired!

  """Authorization required to change permissions"""
  setPermissions: AccountAuthRequired!

  """
  Authorization required to set the verification key of the zkApp associated with the account
  """
  setVerificationKey: VerificationKeyPermission!

  """
  Authorization required to change the URI of the zkApp associated with the account 
  """
  setZkappUri: AccountAuthRequired!

  """Authorization required to edit the action state"""
  editActionState: AccountAuthRequired!

  """Authorization required to set the token symbol"""
  setTokenSymbol: AccountAuthRequired!

  """Authorization required to increment the nonce"""
  incrementNonce: AccountAuthRequired!

  """Authorization required to set the state hash the account is voting for"""
  setVotingFor: AccountAuthRequired!

  """Authorization required to set the timing of the account"""
  setTiming: AccountAuthRequired!
}

type AccountPrecondition {
  balance: BalanceInterval
  nonce: NonceInterval
  receiptChainHash: Field
  delegate: PublicKey
  state: [Field]!
  actionState: Field
  provedState: Boolean
  isNew: Boolean
}

input AccountPreconditionInput {
  balance: BalanceIntervalInput
  nonce: NonceIntervalInput
  receiptChainHash: Field
  delegate: PublicKey
  state: [Field]!
  actionState: Field
  provedState: Boolean
  isNew: Boolean
}

type AccountTiming {
  """The initial minimum balance for a time-locked account"""
  initialMinimumBalance: Balance

  """The cliff time for a time-locked account"""
  cliffTime: Globalslot

  """The cliff amount for a time-locked account"""
  cliffAmount: Amount

  """The vesting period for a time-locked account"""
  vestingPeriod: GlobalSlotSpan

  """The vesting increment for a time-locked account"""
  vestingIncrement: Amount
}

type AccountUpdateBody {
  publicKey: PublicKey!
  tokenId: TokenId!
  update: AccountUpdateModification!
  balanceChange: BalanceChange!
  incrementNonce: Boolean!
  events: [[Field!]!]!
  actions: [[Field!]!]!
  callData: Field!
  callDepth: Int!
  preconditions: Preconditions!
  useFullCommitment: Boolean!
  implicitAccountCreationFee: Boolean!
  mayUseToken: MayUseToken!
  authorizationKind: AuthorizationKindStructured!
}

input AccountUpdateBodyInput {
  publicKey: PublicKey!
  tokenId: TokenId!
  update: AccountUpdateModificationInput!
  balanceChange: BalanceChangeInput!
  incrementNonce: Boolean!
  events: [[Field!]!]!
  actions: [[Field!]!]!
  callData: Field!
  callDepth: Int!
  preconditions: PreconditionsInput!
  useFullCommitment: Boolean!
  implicitAccountCreationFee: Boolean!
  mayUseToken: MayUseTokenInput!
  authorizationKind: AuthorizationKindStructuredInput!
}

type AccountUpdateModification {
  appState: [Field]!
  delegate: PublicKey
  verificationKey: VerificationKeyWithHash
  permissions: Permissions
  zkappUri: String
  tokenSymbol: String
  timing: Timing
  votingFor: StateHash
}

input AccountUpdateModificationInput {
  appState: [Field]!
  delegate: PublicKey
  verificationKey: VerificationKeyWithHashInput
  permissions: PermissionsInput
  zkappUri: String
  tokenSymbol: String
  timing: TimingInput
  votingFor: StateHash
}

"""Verification key with hash"""
type AccountVerificationKeyWithHash {
  """verification key in Base64 format"""
  verificationKey: VerificationKey!

  """Hash of verification key"""
  hash: VerificationKeyHash!
}

"""action"""
scalar Action

input AddAccountInput {
  """Password used to encrypt the new account"""
  password: String!
}

type AddAccountPayload {
  """Public key of the created account"""
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  """Details of created account"""
  account: Account!
}

type AddrsAndPorts {
  externalIp: String!
  bindIp: String!
  peer: Peer
  libp2pPort: Int!
  clientPort: Int!
}

"""amount"""
scalar Amount

"""
A total balance annotated with the amount that is currently unknown with the
invariant unknown <= total, as well as the currently liquid and locked balances.
"""
type AnnotatedBalance {
  """The amount of MINA owned by the account"""
  total: Balance!

  """
  The amount of MINA owned by the account whose origin is currently unknown
  """
  unknown: Balance!

  """
  The amount of MINA owned by the account which is currently available. Can be null if bootstrapping.
  """
  liquid: Balance

  """
  The amount of MINA owned by the account which is currently locked. Can be null if bootstrapping.
  """
  locked: Balance

  """Block height at which balance was measured"""
  blockHeight: Length!

  """
  Hash of block at which balance was measured. Can be null if bootstrapping.
  Guaranteed to be non-null for direct account lookup queries when not
  bootstrapping. Can also be null when accessed as nested properties (eg. via delegators). 
  """
  stateHash: StateHash
}

type Applied {
  applied: Boolean!
}

type AuthorizationKindStructured {
  isSigned: Boolean!
  isProved: Boolean!
  verificationKeyHash: Field!
}

input AuthorizationKindStructuredInput {
  isSigned: Boolean!
  isProved: Boolean!
  verificationKeyHash: Field!
}

"""Kind of authorization required"""
scalar AuthRequired

"""balance"""
scalar Balance

type BalanceChange {
  magnitude: CurrencyAmount!
  sgn: Sign!
}

input BalanceChangeInput {
  magnitude: CurrencyAmount!
  sgn: Sign!
}

type BalanceInterval {
  lower: Balance!
  upper: Balance!
}

input BalanceIntervalInput {
  lower: Balance!
  upper: Balance!
}

type Block {
  """Public key of account that produced this block"""
  creator: PublicKey! @deprecated(reason: "use creatorAccount field instead")

  """Account that produced this block"""
  creatorAccount: Account!

  """Account that won the slot (Delegator/Staker)"""
  winnerAccount: Account!

  """Base58Check-encoded hash of the state after this block"""
  stateHash: StateHash!

  """Experimental: Bigint field-element representation of stateHash"""
  stateHashField: StateHashAsDecimal!
  protocolState: ProtocolState!

  """Snark proof of blockchain state"""
  protocolStateProof: protocolStateProof!
  transactions: Transactions!

  """Count of user command transactions in the block"""
  commandTransactionCount: Int!
  snarkJobs: [CompletedWork!]!
}

type BlockchainState {
  """
  date (stringified Unix time - number of milliseconds since January 1, 1970)
  """
  date: BlockTime!

  """
  utcDate (stringified Unix time - number of milliseconds since January 1,
  1970). Time offsets are adjusted to reflect true wall-clock time instead of genesis time.
  """
  utcDate: BlockTime!

  """Base58Check-encoded hash of the snarked ledger"""
  snarkedLedgerHash: LedgerHash!

  """Base58Check-encoded hash of the staged ledger hash's main ledger hash"""
  stagedLedgerHash: LedgerHash!

  """Base58Check-encoded hash of the staged ledger hash's aux_hash"""
  stagedLedgerAuxHash: StagedLedgerAuxHash!

  """Base58Check-encoded staged ledger hash's pending_coinbase_aux"""
  stagedLedgerPendingCoinbaseAux: PendingCoinbaseAuxHash!

  """
  Base58Check-encoded hash of the staged ledger hash's pending_coinbase_hash
  """
  stagedLedgerPendingCoinbaseHash: PendingCoinbaseHash!

  """
  Block finished a staged ledger, and a proof was emitted from it and included
  into this block's proof. If there is no transition frontier available or no
  block found, this will return null.
  """
  stagedLedgerProofEmitted: Boolean

  """
  A reference to how the block header refers to the body of the block as a hex-encoded string
  """
  bodyReference: BodyReference!
}

type BlockProducerTimings {
  """Next block production time"""
  times: [ConsensusTime!]!

  """Next block production global-slot-since-genesis """
  globalSlotSinceGenesis: [Globalslot!]!

  """
  Consensus time of the block that was used to determine the next block production time
  """
  generatedFromConsensusAt: ConsensusTimeGlobalSlot!
}

scalar BlockTime

"""
A reference to how the block header refers to the body of the block as a hex-encoded string
"""
scalar BodyReference

"""Base58Check-encoded chain hash"""
scalar ChainHash

"""Status for whenever the blockchain is reorganized"""
enum ChainReorganizationStatus {
  CHANGED
}

"""Completed snark works"""
type CompletedWork {
  """Public key of the prover"""
  prover: PublicKey!

  """Amount the prover is paid for the snark work"""
  fee: Fee!

  """Unique identifier for the snark work purchased"""
  workIds: [Int!]!
}

type ConsensusConfiguration {
  delta: Int!
  k: Int!
  slotsPerEpoch: Int!
  slotDuration: Int!
  epochDuration: Int!
  genesisStateTimestamp: Time!
  acceptableNetworkDelay: Int!
}

type ConsensusState {
  """Length of the blockchain at this block"""
  blockchainLength: Length! @deprecated(reason: "use blockHeight instead")

  """Height of the blockchain at this block"""
  blockHeight: Length!
  epochCount: Length!
  minWindowDensity: Length!
  lastVrfOutput: String!

  """Total currency in circulation at this block"""
  totalCurrency: Amount!
  stakingEpochData: StakingEpochData!
  nextEpochData: NextEpochData!
  hasAncestorInSameCheckpointWindow: Boolean!

  """Slot in which this block was created"""
  slot: Slot!

  """Slot since genesis (across all hard-forks)"""
  slotSinceGenesis: Globalslot!

  """Epoch in which this block was created"""
  epoch: Epoch!

  """
  Whether or not this coinbase was "supercharged", ie. created by an account that has no locked tokens
  """
  superchargedCoinbase: Boolean!

  """
  The public key that is responsible for winning this block (including delegations)
  """
  blockStakeWinner: PublicKey!

  """The block producer public key that created this block"""
  blockCreator: PublicKey!
  coinbaseReceiever: PublicKey!
}

type ConsensusTime {
  epoch: UInt32!
  slot: UInt32!
  globalSlot: GlobalSlotSinceHardFork!
  startTime: BlockTime!
  endTime: BlockTime!
}

"""Consensus time and the corresponding global slot since genesis"""
type ConsensusTimeGlobalSlot {
  """
  Time in terms of slot number in an epoch, start and end time of the slot since UTC epoch
  """
  consensusTime: ConsensusTime!
  globalSlotSinceGenesis: Globalslot!
}

type Control {
  proof: ZkappProof
  signature: Signature
}

input ControlInput {
  proof: ZkappProof
  signature: Signature
}

input CreateHDAccountInput {
  """Index of the account in hardware wallet"""
  index: UInt32!
}

scalar CurrencyAmount

type CurrencyAmountInterval {
  lower: CurrencyAmount!
  upper: CurrencyAmount!
}

input CurrencyAmountIntervalInput {
  lower: CurrencyAmount!
  upper: CurrencyAmount!
}

type DaemonStatus {
  numAccounts: Int
  blockchainLength: Int
  highestBlockLengthReceived: Int!
  highestUnvalidatedBlockLengthReceived: Int!
  uptimeSecs: Int!
  ledgerMerkleRoot: String
  stateHash: String
  chainId: String!
  commitId: String!
  confDir: String!
  peers: [Peer!]!
  userCommandsSent: Int!
  snarkWorker: String
  snarkWorkFee: Int!
  syncStatus: SyncStatus!
  catchupStatus: [String!]
  blockProductionKeys: [String!]!
  coinbaseReceiver: String
  histograms: Histograms
  consensusTimeBestTip: ConsensusTime
  globalSlotSinceGenesisBestTip: Int
  nextBlockProduction: BlockProducerTimings
  consensusTimeNow: ConsensusTime!
  consensusMechanism: String!
  consensusConfiguration: ConsensusConfiguration!
  addrsAndPorts: AddrsAndPorts!
  metrics: Metrics!
}

input DeleteAccountInput {
  """Public key of account to be deleted"""
  publicKey: PublicKey!
}

type DeleteAccountPayload {
  """Public key of the deleted account"""
  publicKey: PublicKey!
}

"""epoch"""
scalar Epoch

type EpochDataPrecondition {
  ledger: EpochLedgerPrecondition!
  seed: Field
  startCheckpoint: Field
  lockCheckpoint: Field
  epochLength: LengthInterval
}

input EpochDataPreconditionInput {
  ledger: EpochLedgerPreconditionInput!
  seed: Field
  startCheckpoint: Field
  lockCheckpoint: Field
  epochLength: LengthIntervalInput
}

type epochLedger {
  hash: LedgerHash!
  totalCurrency: Amount!
}

type EpochLedgerPrecondition {
  hash: Field
  totalCurrency: CurrencyAmountInterval
}

input EpochLedgerPreconditionInput {
  hash: Field
  totalCurrency: CurrencyAmountIntervalInput
}

"""Base58Check-encoded epoch seed"""
scalar EpochSeed

type ExportLogsPayload {
  """Tar archive containing logs"""
  exportLogs: TarFile!
}

"""Block encoded in extensional block format"""
scalar ExtensionalBlock

"""fee"""
scalar Fee

type FeePayerBody {
  publicKey: PublicKey!
  fee: Fee!
  validUntil: GlobalSlotSinceGenesis
  nonce: UInt32!
}

input FeePayerBodyInput {
  publicKey: PublicKey!
  fee: Fee!
  validUntil: GlobalSlotSinceGenesis
  nonce: UInt32!
}

type FeeTransfer {
  """Public key of fee transfer recipient"""
  recipient: PublicKey!

  """Amount that the recipient is paid in this fee transfer"""
  fee: Fee!

  """
  Fee_transfer|Fee_transfer_via_coinbase Snark worker fees deducted from the
  coinbase amount are of type 'Fee_transfer_via_coinbase', rest are deducted
  from transaction fees
  """
  type: FeeTransferType!
}

"""fee transfer type"""
scalar FeeTransferType

"""String representing an Fp Field element"""
scalar Field

"""field element"""
scalar FieldElem

type GenesisConstants {
  """The fee charged to create a new account"""
  accountCreationFee: Fee!

  """The amount received as a coinbase reward for producing a block"""
  coinbase: Amount!

  """The genesis timestamp in ISO 8601 format"""
  genesisTimestamp: String!
}

type GetFilteredLogEntries {
  """Structured log messages since the given offset"""
  logMessages: [String!]!

  """Whether we are capturing structured log messages"""
  isCapturing: Boolean!
}

"""global slot"""
scalar Globalslot

scalar GlobalSlotSinceGenesis

type GlobalSlotSinceGenesisInterval {
  lower: GlobalSlotSinceGenesis!
  upper: GlobalSlotSinceGenesis!
}

input GlobalSlotSinceGenesisIntervalInput {
  lower: GlobalSlotSinceGenesis!
  upper: GlobalSlotSinceGenesis!
}

"""global slot since hard fork"""
scalar GlobalSlotSinceHardFork

"""global slot span"""
scalar GlobalSlotSpan

type Histogram {
  values: [Int!]!
  intervals: [Interval!]!
  underflow: Int!
  overflow: Int!
}

type Histograms {
  rpcTimings: RpcTimings!
  externalTransitionLatency: Histogram
  acceptedTransitionLocalLatency: Histogram
  acceptedTransitionRemoteLatency: Histogram
  snarkWorkerTransitionTime: Histogram
  snarkWorkerMergeTime: Histogram
}

type ImportAccountPayload {
  """The public key of the imported account"""
  publicKey: PublicKey!

  """True if the account had already been imported"""
  alreadyImported: Boolean!
  success: Boolean!
}

"""ocaml integer as a string"""
scalar Index

"""network address"""
scalar InetAddr

type Interval {
  start: Span!
  stop: Span!
}

"""Arbitrary JSON"""
scalar JSON

"""Base58Check-encoded ledger hash"""
scalar LedgerHash

"""length"""
scalar Length

type LengthInterval {
  lower: UInt32!
  upper: UInt32!
}

input LengthIntervalInput {
  lower: UInt32!
  upper: UInt32!
}

input LockInput {
  """Public key specifying which account to lock"""
  publicKey: PublicKey!
}

type LockPayload {
  """Public key of the locked account"""
  publicKey: PublicKey!

  """Details of locked account"""
  account: Account!
}

type MayUseToken {
  parentsOwnToken: Boolean!
  inheritFromParent: Boolean!
}

input MayUseTokenInput {
  parentsOwnToken: Boolean!
  inheritFromParent: Boolean!
}

scalar Memo

type MerklePathElement {
  left: FieldElem
  right: FieldElem
}

type Metrics {
  blockProductionDelay: [Int!]!
  transactionPoolDiffReceived: Int!
  transactionPoolDiffBroadcasted: Int!
  transactionsAddedToPool: Int!
  transactionPoolSize: Int!
  snarkPoolDiffReceived: Int!
  snarkPoolDiffBroadcasted: Int!
  pendingSnarkWork: Int!
  snarkPoolSize: Int!
}

type mutation {
  """
  Add a wallet - this will create a new keypair and store it in the daemon
  """
  addWallet(input: AddAccountInput!): AddAccountPayload! @deprecated(reason: "use createAccount instead")

  """
  TESTING ONLY: Start filtering and recording all structured events in memory
  """
  startFilteredLog(filter: [String!]!): Boolean!

  """
  Create a new account - this will create a new keypair and store it in the daemon
  """
  createAccount(input: AddAccountInput!): AddAccountPayload!

  """
  Create an account with hardware wallet - this will let the hardware wallet
  generate a keypair corresponds to the HD-index you give and store this
  HD-index and the generated public key in the daemon. Calling this command with
  the same HD-index and the same hardware wallet will always generate the same keypair.
  """
  createHDAccount(input: CreateHDAccountInput!): AddAccountPayload!

  """Allow transactions to be sent from the unlocked account"""
  unlockAccount(input: UnlockInput!): UnlockPayload!

  """Allow transactions to be sent from the unlocked account"""
  unlockWallet(input: UnlockInput!): UnlockPayload! @deprecated(reason: "use unlockAccount instead")

  """Lock an unlocked account to prevent transaction being sent from it"""
  lockAccount(input: LockInput!): LockPayload!

  """Lock an unlocked account to prevent transaction being sent from it"""
  lockWallet(input: LockInput!): LockPayload! @deprecated(reason: "use lockAccount instead")

  """Delete the private key for an account that you track"""
  deleteAccount(input: DeleteAccountInput!): DeleteAccountPayload!

  """Delete the private key for an account that you track"""
  deleteWallet(input: DeleteAccountInput!): DeleteAccountPayload! @deprecated(reason: "use deleteAccount instead")

  """Reload tracked account information from disk"""
  reloadAccounts: ReloadAccountsPayload!

  """Reload tracked account information from disk"""
  importAccount(
    """Password for the account to import"""
    password: String!

    """
    Path to the wallet file, relative to the daemon's current working directory.
    """
    path: String!
  ): ImportAccountPayload!

  """Reload tracked account information from disk"""
  reloadWallets: ReloadAccountsPayload! @deprecated(reason: "use reloadAccounts instead")

  """Send a payment"""
  sendPayment(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput
    input: SendPaymentInput!
  ): SendPaymentPayload!

  """Send a series of test payments"""
  sendTestPayments(
    """Delay with which a transaction shall be repeated"""
    repeat_delay_ms: UInt32!

    """How many times shall transaction be repeated"""
    repeat_count: UInt32!

    """The fee of each payment"""
    fee: UInt64!

    """The amount of each payment"""
    amount: UInt64!

    """The receiver of the payments"""
    receiver: PublicKey!

    """The private keys from which to sign the payments"""
    senders: [PrivateKey!]!
  ): Int!

  """Change your delegate by sending a transaction"""
  sendDelegation(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput
    input: SendDelegationInput!
  ): SendDelegationPayload!

  """Send a zkApp transaction"""
  sendZkapp(input: SendZkappInput!): SendZkappPayload!

  """Mock a zkApp transaction, no effect on blockchain"""
  mockZkapp(input: SendZkappInput!): SendZkappPayload!

  """Send zkApp transactions (for internal testing purposes)"""
  internalSendZkapp(zkappCommands: [SendTestZkappInput!]!): [SendZkappPayload!]!

  """Export daemon logs to tar archive"""
  exportLogs(basename: String): ExportLogsPayload!

  """Set the key to receive coinbases"""
  setCoinbaseReceiver(input: SetCoinbaseReceiverInput!): SetCoinbaseReceiverPayload!

  """Set key you wish to snark work with or disable snark working"""
  setSnarkWorker(input: SetSnarkWorkerInput!): SetSnarkWorkerPayload!

  """Set fee that you will like to receive for doing snark work"""
  setSnarkWorkFee(input: SetSnarkWorkFee!): SetSnarkWorkFeePayload!

  """
  Set the connection gating config, returning the current config after the application (which may have failed)
  """
  setConnectionGatingConfig(input: SetConnectionGatingConfigInput!): SetConnectionGatingConfigPayload!

  """Connect to the given peers"""
  addPeers(seed: Boolean, peers: [NetworkPeer!]!): [Peer!]!
  archivePrecomputedBlock(
    """Block encoded in precomputed block format"""
    block: PrecomputedBlock!
  ): Applied!
  archiveExtensionalBlock(
    """Block encoded in extensional block format"""
    block: ExtensionalBlock!
  ): Applied!

  """Send a transaction in Rosetta format"""
  sendRosettaTransaction(input: RosettaTransaction!): SendRosettaTransactionPayload!
}

"""Network identifiers for another protocol participant"""
input NetworkPeer {
  libp2pPort: Int!

  """IP address of the remote host"""
  host: String!

  """base58-encoded peer ID"""
  peerId: String!
}

type NetworkPeerPayload {
  """base58-encoded peer ID"""
  peerId: String!

  """IP address of the remote host"""
  host: InetAddr!
  libp2pPort: Int!
}

type NetworkPrecondition {
  snarkedLedgerHash: Field
  blockchainLength: LengthInterval
  minWindowDensity: LengthInterval
  totalCurrency: CurrencyAmountInterval
  globalSlotSinceGenesis: GlobalSlotSinceGenesisInterval
  stakingEpochData: EpochDataPrecondition!
  nextEpochData: EpochDataPrecondition!
}

input NetworkPreconditionInput {
  snarkedLedgerHash: Field
  blockchainLength: LengthIntervalInput
  minWindowDensity: LengthIntervalInput
  totalCurrency: CurrencyAmountIntervalInput
  globalSlotSinceGenesis: GlobalSlotSinceGenesisIntervalInput
  stakingEpochData: EpochDataPreconditionInput!
  nextEpochData: EpochDataPreconditionInput!
}

type NextEpochData {
  ledger: epochLedger!
  seed: EpochSeed!
  startCheckpoint: StateHash!
  lockCheckpoint: String!
  epochLength: Length!
}

type NonceInterval {
  lower: UInt32!
  upper: UInt32!
}

input NonceIntervalInput {
  lower: UInt32!
  upper: UInt32!
}

type Peer {
  host: String!
  libp2pPort: Int!
  peerId: String!
}

"""Base58Check-encoded hash of a pending coinbase auxiliary hash"""
scalar PendingCoinbaseAuxHash

"""Base58Check-encoded hash of a pending coinbase hash"""
scalar PendingCoinbaseHash

"""Snark work bundles that are not available in the pool yet"""
type PendingSnarkWork {
  """Work bundle with one or two snark work"""
  workBundle: [WorkDescription!]!
}

type Permissions {
  editState: AuthRequired!
  access: AuthRequired!
  send: AuthRequired!
  receive: AuthRequired!
  setDelegate: AuthRequired!
  setPermissions: AuthRequired!
  setVerificationKey: VerificationKeyPermission!
  setZkappUri: AuthRequired!
  editActionState: AuthRequired!
  setTokenSymbol: AuthRequired!
  incrementNonce: AuthRequired!
  setVotingFor: AuthRequired!
  setTiming: AuthRequired!
}

input PermissionsInput {
  editState: AuthRequired!
  access: AuthRequired!
  send: AuthRequired!
  receive: AuthRequired!
  setDelegate: AuthRequired!
  setPermissions: AuthRequired!
  setVerificationKey: VerificationKeyPermissionInput!
  setZkappUri: AuthRequired!
  editActionState: AuthRequired!
  setTokenSymbol: AuthRequired!
  incrementNonce: AuthRequired!
  setVotingFor: AuthRequired!
  setTiming: AuthRequired!
}

"""Block encoded in precomputed block format"""
scalar PrecomputedBlock

"""Base-64 encoded proof"""
scalar PrecomputedBlockProof

type Preconditions {
  network: NetworkPrecondition!
  account: AccountPrecondition!
  validWhile: GlobalSlotSinceGenesisInterval
}

input PreconditionsInput {
  network: NetworkPreconditionInput!
  account: AccountPreconditionInput!
  validWhile: GlobalSlotSinceGenesisIntervalInput
}

"""Base58Check-encoded private key"""
scalar PrivateKey

type ProtocolState {
  """Base58Check-encoded hash of the previous state"""
  previousStateHash: StateHash!

  """State which is agnostic of a particular consensus algorithm"""
  blockchainState: BlockchainState!

  """State specific to the minaboros Proof of Stake consensus algorithm"""
  consensusState: ConsensusState!
}

type protocolStateProof {
  """Base-64 encoded proof"""
  base64: PrecomputedBlockProof

  """JSON-encoded proof"""
  json: JSON
}

"""Base58Check-encoded public key string"""
scalar PublicKey

type query {
  """Network sync status"""
  syncStatus: SyncStatus!

  """Get running daemon status"""
  daemonStatus: DaemonStatus!

  """The version of the node (git commit hash)"""
  version: String

  """TESTING ONLY: Retrieve all new structured events in memory"""
  getFilteredLogEntries(offset: Int!): GetFilteredLogEntries!

  """Wallets for which the daemon knows the private key"""
  ownedWallets: [Account!]! @deprecated(reason: "use trackedAccounts instead")

  """Accounts for which the daemon tracks the private key"""
  trackedAccounts: [Account!]!

  """Find any wallet via a public key"""
  wallet(
    """Public key of account being retrieved"""
    publicKey: PublicKey!
  ): Account @deprecated(reason: "use account instead")

  """
  The rules that the libp2p helper will use to determine which connections to permit
  """
  connectionGatingConfig: SetConnectionGatingConfigPayload!

  """Find any account via a public key and token"""
  account(
    """Token of account being retrieved (defaults to MINA)"""
    token: TokenId

    """Public key of account being retrieved"""
    publicKey: PublicKey!
  ): Account

  """Find all accounts for a public key"""
  accounts(
    """Public key to find accounts for"""
    publicKey: PublicKey!
  ): [Account!]!

  """Find the account that owns a given token"""
  tokenOwner(
    """Token ID to find the owning account for"""
    tokenId: TokenId!
  ): Account

  """Find all accounts for a token ID"""
  tokenAccounts(
    """Token ID to find accounts for"""
    tokenId: TokenId!
  ): [Account!]!

  """Get information about the current snark worker"""
  currentSnarkWorker: SnarkWorker

  """
  Retrieve a list of blocks from transition frontier's root to the current best
  tip. Returns an error if the system is bootstrapping.
  """
  bestChain(
    """
    The maximum number of blocks to return. If there are more blocks in the
    transition frontier from root to tip, the n blocks closest to the best tip
    will be returned
    """
    maxLength: Int
  ): [Block!]

  """
  Retrieve a block with the given state hash or height, if contained in the transition frontier.
  """
  block(
    """The height of the desired block in the best chain"""
    height: Int

    """The state hash of the desired block"""
    stateHash: String
  ): Block!

  """Get the genesis block"""
  genesisBlock: Block!

  """List of peers that the daemon first used to connect to the network"""
  initialPeers: [String!]!

  """List of peers that the daemon is currently connected to"""
  getPeers: [Peer!]!

  """
  Retrieve all the scheduled user commands for a specified sender that the
  current daemon sees in its transaction pool. All scheduled commands are
  queried if no sender is specified
  """
  pooledUserCommands(
    """Ids of User commands"""
    ids: [ID!]

    """Hashes of the commands to find in the pool"""
    hashes: [String!]

    """Public key of sender of pooled user commands"""
    publicKey: PublicKey
  ): [UserCommand!]!

  """
  Retrieve all the scheduled zkApp commands for a specified sender that the
  current daemon sees in its transaction pool. All scheduled commands are
  queried if no sender is specified
  """
  pooledZkappCommands(
    """Ids of zkApp commands"""
    ids: [ID!]

    """Hashes of the zkApp commands to find in the pool"""
    hashes: [String!]

    """Public key of sender of pooled zkApp commands"""
    publicKey: PublicKey
  ): [ZkappCommandResult!]!

  """Get the status of a transaction"""
  transactionStatus(
    """Id of a zkApp transaction"""
    zkappTransaction: ID

    """Id of a Payment"""
    payment: ID
  ): TransactionStatus!

  """Trust status for an IPv4 or IPv6 address"""
  trustStatus(ipAddress: String!): [TrustStatusPayload!]

  """IP address and trust status for all peers"""
  trustStatusAll: [TrustStatusPayload!]!

  """List of completed snark works that have the lowest fee so far"""
  snarkPool: [CompletedWork!]!

  """List of snark works that are yet to be done"""
  pendingSnarkWork: [PendingSnarkWork!]!

  """
  The constants used to determine the configuration of the genesis block and all of its transitive dependencies
  """
  genesisConstants: GenesisConstants!

  """
  The time offset in seconds used to convert real times into blockchain times
  """
  timeOffset: Int!

  """Validate the format and signature of a payment"""
  validatePayment(
    """
    If a signature is provided, this transaction is considered signed and will
    be broadcasted to the network without requiring a private key
    """
    signature: SignatureInput
    input: SendPaymentInput!
  ): Boolean!

  """
  Evaluate a vrf for the given public key. This includes a witness which may be
  verified without access to the private key for this vrf evaluation.
  """
  evaluateVrf(vrfThreshold: VrfThresholdInput, publicKey: PublicKey!, message: VrfMessageInput!): VrfEvaluation!

  """
  Check a vrf evaluation commitment. This can be used to check vrf evaluations
  without needing to reveal the private key, in the format returned by evaluateVrf
  """
  checkVrf(input: VrfEvaluationInput!): VrfEvaluation!

  """The runtime configuration passed to the daemon at start-up"""
  runtimeConfig: JSON!

  """
  The runtime configuration for a blockchain fork intended to be a continuation
  of the current one. By default, this returns the newest block that appeared
  before the transaction stop slot provided in the configuration, or the best
  tip if no such block exists.
  """
  fork_config(
    """The height of the desired block in the best chain"""
    height: Int

    """The state hash of the desired block"""
    stateHash: String
  ): JSON!

  """
  A graphviz dot format representation of the deamon's internal thread graph
  """
  threadGraph: String!

  """The pickles verification key for the protocol state proof"""
  blockchainVerificationKey: JSON!

  """
  The chain-agnostic identifier of the network this daemon is participating in
  """
  networkID: String!

  """The signature kind that this daemon instance is using"""
  signatureKind: String!
}

type ReloadAccountsPayload {
  """True when the reload was successful"""
  success: Boolean!
}

"""A transaction encoded in the Rosetta format"""
scalar RosettaTransaction

type RpcPair {
  dispatch: Histogram
  impl: Histogram
}

type RpcTimings {
  getStagedLedgerAux: RpcPair!
  answerSyncLedgerQuery: RpcPair!
  getAncestry: RpcPair!
  getTransitionChainProof: RpcPair!
  getTransitionChain: RpcPair!
}

input SendDelegationInput {
  """
  Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  """
  nonce: UInt32

  """Short arbitrary message provided by the sender"""
  memo: String

  """
  The global slot since genesis after which this transaction cannot be applied
  """
  validUntil: UInt32

  """Fee amount in order to send a stake delegation"""
  fee: UInt64!

  """Public key of the account being delegated to"""
  to: PublicKey!

  """Public key of sender of a stake delegation"""
  from: PublicKey!
}

type SendDelegationPayload {
  """Delegation change that was sent"""
  delegation: UserCommand!
}

input SendPaymentInput {
  """
  Should only be set when cancelling transactions, otherwise a nonce is determined automatically
  """
  nonce: UInt32

  """Short arbitrary message provided by the sender"""
  memo: String

  """
  The global slot since genesis after which this transaction cannot be applied
  """
  validUntil: UInt32

  """Fee amount in order to send payment"""
  fee: UInt64!

  """Amount of MINA to send to receiver"""
  amount: UInt64!

  """Public key of recipient of payment"""
  to: PublicKey!

  """Public key of sender of payment"""
  from: PublicKey!
}

type SendPaymentPayload {
  """Payment that was sent"""
  payment: UserCommand!
}

type SendRosettaTransactionPayload {
  """Command that was sent"""
  userCommand: UserCommand!
}

"""zkApp command for a test zkApp"""
scalar SendTestZkappInput

input SendZkappInput {
  """zkApp command structure representing the transaction"""
  zkappCommand: ZkappCommandInput!
}

type SendZkappPayload {
  """zkApp transaction that was sent"""
  zkapp: ZkappCommandResult!
}

input SetCoinbaseReceiverInput {
  """
  Public key of the account to receive coinbases. Block production keys will
  receive the coinbases if omitted. Warning: If the key is from a zkApp account,
  the account's receive permission must be None.
  """
  publicKey: PublicKey
}

type SetCoinbaseReceiverPayload {
  """
  Returns the public key that was receiving coinbases previously, or none if it was the block producer
  """
  lastCoinbaseReceiver: PublicKey

  """
  Returns the public key that will receive coinbase, or none if it will be the block producer
  """
  currentCoinbaseReceiver: PublicKey
}

input SetConnectionGatingConfigInput {
  """If true, resets added peers to an empty list (including seeds)"""
  cleanAddedPeers: Boolean

  """
  If true, no connections will be allowed unless they are from a trusted peer
  """
  isolate: Boolean!

  """
  Peers we will never allow connections from (unless they are also trusted!)
  """
  bannedPeers: [NetworkPeer!]!

  """Peers we will always allow connections from"""
  trustedPeers: [NetworkPeer!]!
}

type SetConnectionGatingConfigPayload {
  """Peers we will always allow connections from"""
  trustedPeers: [NetworkPeerPayload!]!

  """
  Peers we will never allow connections from (unless they are also trusted!)
  """
  bannedPeers: [NetworkPeerPayload!]!

  """
  If true, no connections will be allowed unless they are from a trusted peer
  """
  isolate: Boolean!
}

input SetSnarkWorkerInput {
  """
  Public key you wish to start snark-working on; null to stop doing any snark
  work. Warning: If the key is from a zkApp account, the account's receive
  permission must be None.
  """
  publicKey: PublicKey
}

type SetSnarkWorkerPayload {
  """Returns the last public key that was designated for snark work"""
  lastSnarkWorker: PublicKey
}

input SetSnarkWorkFee {
  """Fee to get rewarded for producing snark work"""
  fee: UInt64!
}

type SetSnarkWorkFeePayload {
  """Returns the last fee set to do snark work"""
  lastFee: Fee!
}

enum sign {
  PLUS
  MINUS
}

scalar Sign

scalar Signature

"""
A cryptographic signature -- you must provide either field+scalar or rawSignature
"""
input SignatureInput {
  """Raw encoded signature"""
  rawSignature: String

  """Scalar component of signature"""
  scalar: String

  """Field component of signature"""
  field: String
}

"""Signed fee"""
type SignedFee {
  """+/-"""
  sign: sign!

  """Fee"""
  feeMagnitude: Amount!
}

"""slot"""
scalar Slot

type SnarkWorker {
  """Public key of current snark worker"""
  key: PublicKey! @deprecated(reason: "use account field instead")

  """Account of the current snark worker"""
  account: Account!

  """Fee that snark worker is charging to generate a snark proof"""
  fee: Fee!
}

"""span"""
scalar Span

"""Base58Check-encoded hash of the staged ledger hash's aux_hash"""
scalar StagedLedgerAuxHash

type StakingEpochData {
  ledger: epochLedger!
  seed: EpochSeed!
  startCheckpoint: StateHash!
  lockCheckpoint: String!
  epochLength: Length!
}

"""Base58Check-encoded state hash"""
scalar StateHash

"""Experimental: Bigint field-element representation of stateHash"""
scalar StateHashAsDecimal

type subscription {
  """Event that triggers when the network sync status changes"""
  newSyncUpdate: SyncStatus!

  """
  Event that triggers when a new block is created that either contains a
  transaction with the specified public key, or was produced by it. If no public
  key is provided, then the event will trigger for every new block received
  """
  newBlock(
    """Public key that is included in the block"""
    publicKey: PublicKey
  ): Block!

  """
  Event that triggers when the best tip changes in a way that is not a trivial extension of the existing one
  """
  chainReorganization: ChainReorganizationStatus!
}

"""Sync status of daemon"""
enum SyncStatus {
  CONNECTING
  LISTENING
  OFFLINE
  BOOTSTRAP
  SYNCED
  CATCHUP
}

type TarFile {
  tarfile: String!
}

scalar Time

type Timing {
  initialMinimumBalance: Balance!
  cliffTime: GlobalSlotSinceGenesis!
  cliffAmount: CurrencyAmount!
  vestingPeriod: GlobalSlotSpan!
  vestingIncrement: CurrencyAmount!
}

input TimingInput {
  initialMinimumBalance: Balance!
  cliffTime: GlobalSlotSinceGenesis!
  cliffAmount: CurrencyAmount!
  vestingPeriod: GlobalSlotSpan!
  vestingIncrement: CurrencyAmount!
}

"""String representation of a token's UInt64 identifier"""
scalar TokenId

"""Base58Check-encoded transaction hash"""
scalar TransactionHash

"""Base64-encoded transaction"""
scalar TransactionId

"""Different types of transactions in a block"""
type Transactions {
  """
  List of user commands (payments and stake delegations) included in this block
  """
  userCommands: [UserCommand!]!

  """List of zkApp commands included in this block"""
  zkappCommands: [ZkappCommandResult!]!

  """List of fee transfers included in this block"""
  feeTransfer: [FeeTransfer!]!

  """Amount of MINA granted to the producer of this block"""
  coinbase: Amount!

  """Account to which the coinbase for this block was granted"""
  coinbaseReceiverAccount: Account
}

"""Status of a transaction"""
enum TransactionStatus {
  """A transaction that is on the longest chain"""
  INCLUDED

  """
  A transaction either in the transition frontier or in transaction pool but is not on the longest chain
  """
  PENDING

  """
  The transaction has either been snarked, reached finality through consensus or has been dropped
  """
  UNKNOWN
}

"""transaction status failure"""
scalar TransactionStatusFailure

type TrustStatusPayload {
  """IP address"""
  ipAddr: InetAddr!

  """libp2p Peer ID"""
  peerId: String!

  """Trust score"""
  trust: Float!

  """Banned status"""
  bannedStatus: Time
}

"""String representing a uint32 number in base 10"""
scalar UInt32

"""
String or Integer representation of a uint64 number. If the input is a string, it must represent the number in base 10
"""
scalar UInt64

input UnlockInput {
  """Public key specifying which account to unlock"""
  publicKey: PublicKey!

  """Password for the account to be unlocked"""
  password: String!
}

type UnlockPayload {
  """Public key of the unlocked account"""
  publicKey: PublicKey! @deprecated(reason: "use account field instead")

  """Details of unlocked account"""
  account: Account!
}

"""Common interface for user commands"""
interface UserCommand {
  id: TransactionId!
  hash: TransactionHash!

  """String describing the kind of user command"""
  kind: UserCommandKind!

  """Sequence number of command for the fee-payer's account"""
  nonce: Int!

  """Account that the command is sent from"""
  source: Account!

  """Account that the command applies to"""
  receiver: Account!

  """Account that pays the fees for the command"""
  feePayer: Account!

  """The global slot number after which this transaction cannot be applied"""
  validUntil: Globalslot!

  """Token used by the command"""
  token: TokenId!

  """
  Amount that the source is sending to receiver - 0 for commands that are not associated with an amount
  """
  amount: Amount!

  """Token used to pay the fee"""
  feeToken: TokenId!

  """Fee that the fee-payer is willing to pay for making the transaction"""
  fee: Fee!

  """Short arbitrary message provided by the sender"""
  memo: String!

  """
  If true, this represents a delegation of stake, otherwise it is a payment
  """
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """Public key of the sender"""
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """Account of the sender"""
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """Public key of the receiver"""
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """Account of the receiver"""
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """null is no failure, reason for failure otherwise."""
  failureReason: TransactionStatusFailure
}

type UserCommandDelegation implements UserCommand {
  delegator: Account!
  delegatee: Account!
  id: TransactionId!
  hash: TransactionHash!

  """String describing the kind of user command"""
  kind: UserCommandKind!

  """Sequence number of command for the fee-payer's account"""
  nonce: Int!

  """Account that the command is sent from"""
  source: Account!

  """Account that the command applies to"""
  receiver: Account!

  """Account that pays the fees for the command"""
  feePayer: Account! @deprecated(reason: "use source field instead")

  """The global slot number after which this transaction cannot be applied"""
  validUntil: Globalslot!

  """Token used for the transaction"""
  token: TokenId!

  """
  Amount that the source is sending to receiver; 0 for commands without an associated amount
  """
  amount: Amount!

  """Token used to pay the fee"""
  feeToken: TokenId!

  """Fee that the fee-payer is willing to pay for making the transaction"""
  fee: Fee!

  """
  A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  """
  memo: String!

  """If true, this command represents a delegation of stake"""
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """Public key of the sender"""
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """Account of the sender"""
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """Public key of the receiver"""
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """Account of the receiver"""
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """null is no failure or status unknown, reason for failure otherwise."""
  failureReason: TransactionStatusFailure
}

"""The kind of user command"""
scalar UserCommandKind

type UserCommandPayment implements UserCommand {
  id: TransactionId!
  hash: TransactionHash!

  """String describing the kind of user command"""
  kind: UserCommandKind!

  """Sequence number of command for the fee-payer's account"""
  nonce: Int!

  """Account that the command is sent from"""
  source: Account!

  """Account that the command applies to"""
  receiver: Account!

  """Account that pays the fees for the command"""
  feePayer: Account! @deprecated(reason: "use source field instead")

  """The global slot number after which this transaction cannot be applied"""
  validUntil: Globalslot!

  """Token used for the transaction"""
  token: TokenId!

  """
  Amount that the source is sending to receiver; 0 for commands without an associated amount
  """
  amount: Amount!

  """Token used to pay the fee"""
  feeToken: TokenId!

  """Fee that the fee-payer is willing to pay for making the transaction"""
  fee: Fee!

  """
  A short message from the sender, encoded with Base58Check, version byte=0x14; byte 2 of the decoding is the message length
  """
  memo: String!

  """If true, this command represents a delegation of stake"""
  isDelegation: Boolean! @deprecated(reason: "use kind field instead")

  """Public key of the sender"""
  from: PublicKey! @deprecated(reason: "use feePayer field instead")

  """Account of the sender"""
  fromAccount: Account! @deprecated(reason: "use feePayer field instead")

  """Public key of the receiver"""
  to: PublicKey! @deprecated(reason: "use receiver field instead")

  """Account of the receiver"""
  toAccount: Account! @deprecated(reason: "use receiver field instead")

  """null is no failure or status unknown, reason for failure otherwise."""
  failureReason: TransactionStatusFailure
}

"""verification key in Base64 format"""
scalar VerificationKey

"""Hash of verification key"""
scalar VerificationKeyHash

type VerificationKeyPermission {
  """
  Authorization required to set the verification key of the zkApp associated with the account
  """
  auth: AccountAuthRequired!
  txnVersion: String!
}

input VerificationKeyPermissionInput {
  auth: AuthRequired!
  txnVersion: UInt32!
}

type VerificationKeyWithHash {
  data: VerificationKey!
  hash: Field!
}

input VerificationKeyWithHashInput {
  data: VerificationKey!
  hash: Field!
}

"""A witness to a vrf evaluation, which may be externally verified"""
type VrfEvaluation {
  message: VrfMessage!
  publicKey: PublicKey!
  c: VrfScalar!
  s: VrfScalar!

  """A group element represented as 2 field elements"""
  scaledMessageHash: [String!]!
  vrfThreshold: VrfThreshold

  """
  The vrf output derived from the evaluation witness. If null, the vrf witness was invalid.
  """
  vrfOutput: VrfOutputTruncated

  """
  The vrf output derived from the evaluation witness, as a fraction. This
  represents a won slot if vrfOutputFractional <= (1 - (1 /
  4)^(delegated_balance / total_stake)). If null, the vrf witness was invalid.
  """
  vrfOutputFractional: Float

  """Whether the threshold to produce a block was met, if specified"""
  thresholdMet(
    """Override for delegation threshold"""
    input: VrfThresholdInput
  ): Boolean
}

"""The witness to a vrf evaluation"""
input VrfEvaluationInput {
  vrfThreshold: VrfThresholdInput
  scaledMessageHash: [String!]!
  s: String!
  c: String!
  publicKey: PublicKey!
  message: VrfMessageInput!
}

"""The inputs to a vrf evaluation"""
type VrfMessage {
  globalSlot: GlobalSlotSinceHardFork!
  epochSeed: EpochSeed!

  """Position in the ledger of the delegator's account"""
  delegatorIndex: Int!
}

"""The inputs to a vrf evaluation"""
input VrfMessageInput {
  """Position in the ledger of the delegator's account"""
  delegatorIndex: Int!

  """Formatted with base58check"""
  epochSeed: String!
  globalSlot: UInt32!
}

"""truncated vrf output"""
scalar VrfOutputTruncated

"""consensus vrf scalar"""
scalar VrfScalar

"""
The amount of stake delegated, used to determine the threshold for a vrf evaluation winning a slot
"""
type VrfThreshold {
  """
  The amount of stake delegated to the vrf evaluator by the delegating account.
  This should match the amount in the epoch's staking ledger, which may be
  different to the amount in the current ledger.
  """
  delegatedStake: Balance!

  """
  The total amount of stake across all accounts in the epoch's staking ledger.
  """
  totalStake: Amount!
}

"""
The amount of stake delegated, used to determine the threshold for a vrf evaluation producing a block
"""
input VrfThresholdInput {
  """
  The total amount of stake across all accounts in the epoch's staking ledger.
  """
  totalStake: UInt64!

  """
  The amount of stake delegated to the vrf evaluator by the delegating account.
  This should match the amount in the epoch's staking ledger, which may be
  different to the amount in the current ledger.
  """
  delegatedStake: UInt64!
}

"""
Transition from a source ledger to a target ledger with some fee excess and increase in supply 
"""
type WorkDescription {
  """Base58Check-encoded hash of the source first-pass ledger"""
  sourceFirstPassLedgerHash: LedgerHash!

  """Base58Check-encoded hash of the target first-pass ledger"""
  targetFirstPassLedgerHash: LedgerHash!

  """Base58Check-encoded hash of the source second-pass ledger"""
  sourceSecondPassLedgerHash: LedgerHash!

  """Base58Check-encoded hash of the target second-pass ledger"""
  targetSecondPassLedgerHash: LedgerHash!

  """
  Total transaction fee that is not accounted for in the transition from source ledger to target ledger
  """
  feeExcess: SignedFee!

  """Increase in total supply"""
  supplyIncrease: Amount! @deprecated(reason: "Use supplyChange")

  """Increase/Decrease in total supply"""
  supplyChange: SignedFee!

  """Unique identifier for a snark work"""
  workId: Int!
}

"""An account update in a zkApp transaction"""
type ZkappAccountUpdate {
  body: AccountUpdateBody!
  authorization: Control!
}

"""An account update in a zkApp transaction"""
input ZkappAccountUpdateInput {
  body: AccountUpdateBodyInput!
  authorization: ControlInput!
}

type ZkappCommand {
  feePayer: ZkappFeePayer!
  accountUpdates: [ZkappAccountUpdate!]!
  memo: Memo!
}

type ZkappCommandFailureReason {
  """List index of the account update that failed"""
  index: Index

  """Failure reason for the account update or any nested zkapp command"""
  failures: [TransactionStatusFailure!]!
}

input ZkappCommandInput {
  feePayer: ZkappFeePayerInput!
  accountUpdates: [ZkappAccountUpdateInput!]!
  memo: Memo!
}

type ZkappCommandResult {
  """A Base64 string representing the zkApp command"""
  id: TransactionId!

  """A cryptographic hash of the zkApp command"""
  hash: TransactionHash!

  """zkApp command representing the transaction"""
  zkappCommand: ZkappCommand!

  """
  The reason for the zkApp transaction failure; null means success or the status is unknown
  """
  failureReason: [ZkappCommandFailureReason]
}

type ZkappFeePayer {
  body: FeePayerBody!
  authorization: Signature!
}

input ZkappFeePayerInput {
  body: FeePayerBodyInput!
  authorization: Signature!
}

scalar ZkappProof

